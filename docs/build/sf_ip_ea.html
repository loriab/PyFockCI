
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sf_ip_ea package &#8212; CAS-nSF-IP/EA  documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CAS-nSF-IP/EA  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sf-ip-ea-package">
<h1>sf_ip_ea package<a class="headerlink" href="#sf-ip-ea-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-sf_ip_ea.bloch">
<span id="sf-ip-ea-bloch-module"></span><h2>sf_ip_ea.bloch module<a class="headerlink" href="#module-sf_ip_ea.bloch" title="Permalink to this headline">¶</a></h2>
<p>Bloch effective Hamiltonian solver.</p>
<p>This module constructs a Bloch effective Hamiltonian for a given SF-IP/EA 
wavefunction. Note that this module is currently dependent on Psi4.</p>
<dl class="function">
<dt id="sf_ip_ea.bloch.do_bloch">
<code class="sig-prename descclassname">sf_ip_ea.bloch.</code><code class="sig-name descname">do_bloch</code><span class="sig-paren">(</span><em class="sig-param">wfn</em>, <em class="sig-param">n_sites</em>, <em class="sig-param">site_list=None</em>, <em class="sig-param">site_list_orbs=None</em>, <em class="sig-param">molden_file='orbs.molden'</em>, <em class="sig-param">skip_localization=False</em>, <em class="sig-param">neutral=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.bloch.do_bloch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bloch effective Hamiltonian solver.</p>
<p>Solves the Bloch effective Hamiltonian and returns a matrix containing 
J coupling information. Sites are designated using <code class="docutils literal notranslate"><span class="pre">site_list</span></code> or 
<code class="docutils literal notranslate"><span class="pre">site_list_orbs</span></code>; if neither of these keywords are specified, 
each orbital in the CAS/RAS2 space is assumed to be its own site. 
A Molden file containing the orbitals is written to <code class="docutils literal notranslate"><span class="pre">orbs.molden</span></code> (or 
whichever file is specified by the user). The J coupling values are 
also written to standard output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sf_wfn</strong><span class="classifier">sf_wfn</span></dt><dd><p>SF-IP-EA wfn object containing info about the calculation.</p>
</dd>
<dt><strong>n_sites</strong><span class="classifier">int</span></dt><dd><p>The number of sites.</p>
</dd>
<dt><strong>site_list</strong><span class="classifier">list</span></dt><dd><p>List of which atoms are “sites”. If this is not given,
the program assumes one orbital per site. Atomic center ordering
starts at zero. Optional.</p>
</dd>
<dt><strong>site_list_orbs</strong><span class="classifier">list</span></dt><dd><p>A list of sites, using lists of orbitals rather 
than atomic centers. (It’s a list of lists. For example, for a 
two-site case where MOs 55, 56, and 59 are on one site and the 
remaining orbitals are on the other, use <code class="docutils literal notranslate"><span class="pre">[[55,56,59],[57,58,60]]</span></code>.) 
Note that ordering starts at 1, not zero, so it follows the same 
indexing as the MO printing in the Psi4 output files. Optional.</p>
</dd>
<dt><strong>molden_file</strong><span class="classifier">string</span></dt><dd><p>Molden filename to which orbitals are written. Optional. 
Defaults to <code class="docutils literal notranslate"><span class="pre">orbs.molden</span></code>.</p>
</dd>
<dt><strong>skip_localization</strong><span class="classifier">bool</span></dt><dd><p>Whether to skip orbital localization. If true, the user should 
localize the orbitals in wfn.wfn beforehand! Optional. 
Defaults to False.</p>
</dd>
<dt><strong>neutral</strong><span class="classifier">bool</span></dt><dd><p>Calculate the J couplings using neutral determinants only. 
Optional. Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>NumPy matrix of J coupling values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sf_ip_ea.bloch.lowdin_orth">
<code class="sig-prename descclassname">sf_ip_ea.bloch.</code><code class="sig-name descname">lowdin_orth</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.bloch.lowdin_orth" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Lowdin orthonormalization on a given matrix A.</p>
<p>Orthonormalizes a given NumPy matrix A based on Lowdin’s approach 
(i.e. based on the SVD of A).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>NumPy array to orthogonalize.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>An orthogonalized version of A.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.f">
<span id="sf-ip-ea-f-module"></span><h2>sf_ip_ea.f module<a class="headerlink" href="#module-sf_ip_ea.f" title="Permalink to this headline">¶</a></h2>
<p>Handling of the Fock matrix.</p>
<p>This module is responsible for handling things related to the Fock matrix.</p>
<dl class="function">
<dt id="sf_ip_ea.f.get_F">
<code class="sig-prename descclassname">sf_ip_ea.f.</code><code class="sig-name descname">get_F</code><span class="sig-paren">(</span><em class="sig-param">wfn</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.f.get_F" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets alpha and beta Fock matrices.</p>
<p>Given a Psi4 Wavefunction object, this returns NumPy representations of 
the alpha and beta Fock matrices in the spatial orbital MO basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wfn</strong><span class="classifier">psi4.core.Wavefunction</span></dt><dd><p>Psi4 wavefunction object from which to obtain alpha and beta 
Fock matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>A tuple (Fa, Fb) containing NumPy representations of the alpha 
and beta Fock matrices, respectively.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.linop">
<span id="sf-ip-ea-linop-module"></span><h2>sf_ip_ea.linop module<a class="headerlink" href="#module-sf_ip_ea.linop" title="Permalink to this headline">¶</a></h2>
<p>LinOp module responsible for performing Hamiltonian-vector multiplication.</p>
<p>This module contains a derived class of NumPy’s LinearOperator. This 
class contains all of the information necessary to do a Hamiltonian-vector 
multiply (the most expensive step in Davidson) using NumPy’s <code class="docutils literal notranslate"><span class="pre">einsum</span></code> 
method.</p>
<dl class="class">
<dt id="sf_ip_ea.linop.LinOpH">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.linop.</code><code class="sig-name descname">LinOpH</code><span class="sig-paren">(</span><em class="sig-param">shape_in</em>, <em class="sig-param">offset_in</em>, <em class="sig-param">ras1_in</em>, <em class="sig-param">ras2_in</em>, <em class="sig-param">ras3_in</em>, <em class="sig-param">Fa_in</em>, <em class="sig-param">Fb_in</em>, <em class="sig-param">tei_in</em>, <em class="sig-param">n_SF_in</em>, <em class="sig-param">delta_ec_in</em>, <em class="sig-param">conf_space_in</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.sparse.linalg.interface.LinearOperator</span></code></p>
<p>Linear operator for Hamiltonian-vector multiplication.</p>
<p>This is a derived class of NumPy’s LinearOperator class. It contains 
information on how to perform tensor-contraction-based multiplication 
of the Hamiltonian with a given vector or set of vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset</strong><span class="classifier">double</span></dt><dd><p>Diagonal offset to Hamiltonian (usually reference energy).</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>The RAS1 space (doubly occupied in reference).</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>The RAS2 space (singly occupied in reference).</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>The RAS3 space (virtual in reference).</p>
</dd>
<dt><strong>n_SF</strong><span class="classifier">int</span></dt><dd><p>Number of spin-flips to perform.</p>
</dd>
<dt><strong>delta_ec</strong><span class="classifier">int</span></dt><dd><p>Change in electron count (indicates IP/EA).</p>
</dd>
<dt><strong>conf_space</strong><span class="classifier">string</span></dt><dd><p>Excitations to include (hole, particle, etc).</p>
</dd>
<dt><strong>num_dets</strong><span class="classifier">int</span></dt><dd><p>Number of determinants.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integrals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(self, x)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjoint</span></code>(self)</p></td>
<td><p>Hermitian adjoint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.diag" title="sf_ip_ea.linop.LinOpH.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a>(self)</p></td>
<td><p>Returns approximate diagonal of Hamiltonian.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf" title="sf_ip_ea.linop.LinOpH.do_cas_1sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_1sf</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do CAS-1SF.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf_ea" title="sf_ip_ea.linop.LinOpH.do_cas_1sf_ea"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_1sf_ea</span></code></a>(self, v, Fa, Fb, tei, …)</p></td>
<td><p>Do CAS-1SF-EA.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf_ip" title="sf_ip_ea.linop.LinOpH.do_cas_1sf_ip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_1sf_ip</span></code></a>(self, v, Fa, Fb, tei, …)</p></td>
<td><p>Do CAS-1SF-IP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf_neutral" title="sf_ip_ea.linop.LinOpH.do_cas_1sf_neutral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_1sf_neutral</span></code></a>(self, v, Fa, Fb, tei, …)</p></td>
<td><p>Do CAS-1SF with neutral determinants only.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_2sf" title="sf_ip_ea.linop.LinOpH.do_cas_2sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_2sf</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do CAS-2SF.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_ea" title="sf_ip_ea.linop.LinOpH.do_cas_ea"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_ea</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do CAS-EA.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_cas_ip" title="sf_ip_ea.linop.LinOpH.do_cas_ip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_cas_ip</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do CAS-IP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_h_1sf" title="sf_ip_ea.linop.LinOpH.do_h_1sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_h_1sf</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(h)-1SF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_h_1sf_ip" title="sf_ip_ea.linop.LinOpH.do_h_1sf_ip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_h_1sf_ip</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(h)-1SF-IP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_h_ea" title="sf_ip_ea.linop.LinOpH.do_h_ea"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_h_ea</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(h)-EA.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_h_ip" title="sf_ip_ea.linop.LinOpH.do_h_ip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_h_ip</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(h)-IP.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_hp_1sf" title="sf_ip_ea.linop.LinOpH.do_hp_1sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_hp_1sf</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(h,p)-1SF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_p_1sf" title="sf_ip_ea.linop.LinOpH.do_p_1sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_p_1sf</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(p)-1SF.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_p_1sf_ea" title="sf_ip_ea.linop.LinOpH.do_p_1sf_ea"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_p_1sf_ea</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(p)-1SF-EA.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_p_ea" title="sf_ip_ea.linop.LinOpH.do_p_ea"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_p_ea</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(p)-EA.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.linop.LinOpH.do_p_ip" title="sf_ip_ea.linop.LinOpH.do_p_ip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">do_p_ip</span></code></a>(self, v, Fa, Fb, tei, offset_v, …)</p></td>
<td><p>Do RAS(p)-IP.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(self, x)</p></td>
<td><p>Matrix-matrix or matrix-vector multiplication.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">matmat</span></code>(self, X)</p></td>
<td><p>Matrix-matrix multiplication.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">matvec</span></code>(self, x)</p></td>
<td><p>Matrix-vector multiplication.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmatvec</span></code>(self, x)</p></td>
<td><p>Adjoint matrix-vector multiplication.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(self)</p></td>
<td><p>Transpose this linear operator.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.diag">
<code class="sig-name descname">diag</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns approximate diagonal of Hamiltonian.</p>
<p>This returns the approximate diagonal of the Hamiltonian for the 
Davidson code (used in the preconditioner step). This is calculated 
for each determinant by summing over the occupied orbital energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>np.ndarray</dt><dd><p>1-D NumPy representation of the diagonal of the Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_1sf">
<code class="sig-name descname">do_cas_1sf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-1SF.</p>
<p>Defines H*v for a CAS-1SF calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ia</span><span class="p">:</span><span class="n">ab</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_1sf_ea">
<code class="sig-name descname">do_cas_1sf_ea</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf_ea" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-1SF-EA.</p>
<p>Defines H*v for a CAS-1SF-EA calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ija</span><span class="p">:</span><span class="n">aab</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_1sf_ip">
<code class="sig-name descname">do_cas_1sf_ip</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-1SF-IP.</p>
<p>Defines H*v for a CAS-1SF-IP calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ija</span><span class="p">:</span><span class="n">aab</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_1sf_neutral">
<code class="sig-name descname">do_cas_1sf_neutral</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_1sf_neutral" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-1SF with neutral determinants only.</p>
<p>Defines H*v for a CAS-1SF calculation, including only neutral 
determinants in the Fock space. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ia</span><span class="p">:</span><span class="n">ab</span><span class="p">)</span> <span class="n">where</span> <span class="n">i</span><span class="o">==</span><span class="n">a</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_2sf">
<code class="sig-name descname">do_cas_2sf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_2sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-2SF.</p>
<p>Defines H*v for a CAS-2SF calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ijab</span><span class="p">:</span><span class="n">aabb</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_ea">
<code class="sig-name descname">do_cas_ea</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_ea" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-EA.</p>
<p>Defines H*v for a CAS-EA calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_cas_ip">
<code class="sig-name descname">do_cas_ip</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_cas_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Do CAS-IP.</p>
<p>Defines H*v for a CAS-IP calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_h_1sf">
<code class="sig-name descname">do_h_1sf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_h_1sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(h)-1SF.</p>
<p>Defines H*v for a RAS(h)-1SF calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ai</span><span class="p">:</span><span class="n">ba</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Ia</span><span class="p">:</span><span class="n">ab</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Iiab</span><span class="p">:</span><span class="n">babb</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_h_1sf_ip">
<code class="sig-name descname">do_h_1sf_ip</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_h_1sf_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(h)-1SF-IP.</p>
<p>Defines H*v for a RAS(h)-1SF-IP calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ija</span><span class="p">:</span><span class="n">aab</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Iia</span><span class="p">:</span><span class="n">aab</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Iijab</span><span class="p">:</span><span class="n">baabb</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_h_ea">
<code class="sig-name descname">do_h_ea</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_h_ea" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(h)-EA.</p>
<p>Defines H*v for a RAS(h)-EA calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">b</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Iab</span><span class="p">:</span><span class="n">bbb</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_h_ip">
<code class="sig-name descname">do_h_ip</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_h_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(h)-IP.</p>
<p>Defines H*v for a RAS(h)-IP calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">a</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">I</span><span class="p">:</span><span class="n">a</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Iia</span><span class="p">:</span><span class="n">bab</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_hp_1sf">
<code class="sig-name descname">do_hp_1sf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_hp_1sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(h,p)-1SF.</p>
<p>Defines H*v for a RAS(h,p)-1SF calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ia</span><span class="p">:</span><span class="n">ab</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Ia</span><span class="p">:</span><span class="n">ab</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">iA</span><span class="p">:</span><span class="n">ab</span><span class="p">)</span>
<span class="n">block4</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Iiab</span><span class="p">:</span><span class="n">babb</span><span class="p">)</span>
<span class="n">block5</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ijAb</span><span class="p">:</span><span class="n">abaa</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_p_1sf">
<code class="sig-name descname">do_p_1sf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_p_1sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(p)-1SF.</p>
<p>Defines H*v for a RAS(p)-1SF calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ai</span><span class="p">:</span><span class="n">ba</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Ai</span><span class="p">:</span><span class="n">ba</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Aaij</span><span class="p">:</span><span class="n">abaa</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_p_1sf_ea">
<code class="sig-name descname">do_p_1sf_ea</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_p_1sf_ea" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(p)-1SF-EA.</p>
<p>Defines H*v for a RAS(p)-1SF-EA calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">iab</span><span class="p">:</span><span class="n">abb</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Aia</span><span class="p">:</span><span class="n">bab</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">Aijab</span><span class="p">:</span><span class="n">baabb</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_p_ea">
<code class="sig-name descname">do_p_ea</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_p_ea" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(p)-EA.</p>
<p>Defines H*v for a RAS(p)-EA calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">b</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="n">b</span><span class="p">)</span>
<span class="n">block3</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">iAa</span><span class="p">:</span><span class="n">aab</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.linop.LinOpH.do_p_ip">
<code class="sig-name descname">do_p_ip</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">v</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei</em>, <em class="sig-param">offset_v</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.linop.LinOpH.do_p_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Do RAS(p)-IP.</p>
<p>Defines H*v for a RAS(p)-IP calculation. Blocks are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block1</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">a</span><span class="p">)</span>
<span class="n">block2</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">ijA</span><span class="p">:</span><span class="n">aaa</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Guess vector to multiply.</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix.</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix.</p>
</dd>
<dt><strong>tei</strong><span class="classifier">TEI</span></dt><dd><p>Two-electron integral object.</p>
</dd>
<dt><strong>offset_v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Vector of offset values for guess vector (usually ROHF energy)</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals.</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals.</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The result of H*v.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.np_sf">
<span id="sf-ip-ea-np-sf-module"></span><h2>sf_ip_ea.np_sf module<a class="headerlink" href="#module-sf_ip_ea.np_sf" title="Permalink to this headline">¶</a></h2>
<p>NumPy-based Fock-space CI.</p>
<p>Runs a RAS-nSF-IP/EA calculation, given the integrals in the form of NumPy 
arrays as input.</p>
<dl class="function">
<dt id="sf_ip_ea.np_sf.do_sf_np">
<code class="sig-prename descclassname">sf_ip_ea.np_sf.</code><code class="sig-name descname">do_sf_np</code><span class="sig-paren">(</span><em class="sig-param">delta_a</em>, <em class="sig-param">delta_b</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em>, <em class="sig-param">Fa</em>, <em class="sig-param">Fb</em>, <em class="sig-param">tei_int</em>, <em class="sig-param">e</em>, <em class="sig-param">conf_space=''</em>, <em class="sig-param">sf_opts={}</em>, <em class="sig-param">J_in=None</em>, <em class="sig-param">C_in=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.np_sf.do_sf_np" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the RAS-SF-IP/EA calculation.</p>
<p>Performs a RAS-SF-IP/EA calculation. The number of spin flips 
and IP/EA is determined by the given parameters delta_a (number 
of alpha electrons removed) and delta_b (number of beta electrons 
added). One- and two-electron integrals are passed in as NumPy 
arrays. Whether to perform hole and/or particle excitations is 
specified using conf_space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>delta_a</strong><span class="classifier">int</span></dt><dd><p>Desired number of alpha electrons to remove</p>
</dd>
<dt><strong>delta_b</strong><span class="classifier">int</span></dt><dd><p>Desired number of beta electrons to add</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Size of RAS1 space</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Size of RAS2 space</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Size of RAS3 space</p>
</dd>
<dt><strong>Fa</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Alpha Fock matrix</p>
</dd>
<dt><strong>Fb</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Beta Fock matrix</p>
</dd>
<dt><strong>tei_int</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Two-electron integrals</p>
</dd>
<dt><strong>e</strong><span class="classifier">float</span></dt><dd><p>ROHF energy</p>
</dd>
<dt><strong>conf_space</strong><span class="classifier">str</span></dt><dd><p>Desired excitation scheme</p>
</dd>
<dt><strong>sf_opts</strong><span class="classifier">dict</span></dt><dd><p>Additional options for spin-flip</p>
</dd>
<dt><strong>J_in</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>J matrix (for DF calculations)</p>
</dd>
<dt><strong>C_in</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>MO coefficients matrix (for DF calculations)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A FockWfn object with calculation information and results</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.post_ci_analysis">
<span id="sf-ip-ea-post-ci-analysis-module"></span><h2>sf_ip_ea.post_ci_analysis module<a class="headerlink" href="#module-sf_ip_ea.post_ci_analysis" title="Permalink to this headline">¶</a></h2>
<p>Handling post-CI analysis.</p>
<p>These are functions to handle post-CI analysis, primarily the S**2 values
and information about the determinants.</p>
<dl class="function">
<dt id="sf_ip_ea.post_ci_analysis.calc_s2">
<code class="sig-prename descclassname">sf_ip_ea.post_ci_analysis.</code><code class="sig-name descname">calc_s2</code><span class="sig-paren">(</span><em class="sig-param">vect</em>, <em class="sig-param">wfn</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.post_ci_analysis.calc_s2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate S**2 for a given Fock CI eigenvector.</p>
<p>Calculates the S**2 expectation value for a given Fock CI eigenvector 
corresponding to a particular state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vect</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Eigenvector for which to compute S**2.</p>
</dd>
<dt><strong>wfn</strong><span class="classifier">FockWfn</span></dt><dd><p>Reference Fock CI wavefunction object for the calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>S**2 value for the given eigenvector.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sf_ip_ea.post_ci_analysis.calc_sz">
<code class="sig-prename descclassname">sf_ip_ea.post_ci_analysis.</code><code class="sig-name descname">calc_sz</code><span class="sig-paren">(</span><em class="sig-param">vect</em>, <em class="sig-param">wfn</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.post_ci_analysis.calc_sz" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Sz for a given Fock CI eigenvector.</p>
<p>Calculates the Sz expectation value for a given Fock CI eigenvector 
corresponding to a particular state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vect</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Eigenvector for which to compute Sz.</p>
</dd>
<dt><strong>wfn</strong><span class="classifier">FockWfn</span></dt><dd><p>Reference Fock CI wavefunction object for the calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Sz value for the given eigenvector.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sf_ip_ea.post_ci_analysis.generate_dets">
<code class="sig-prename descclassname">sf_ip_ea.post_ci_analysis.</code><code class="sig-name descname">generate_dets</code><span class="sig-paren">(</span><em class="sig-param">n_SF</em>, <em class="sig-param">delta_ec</em>, <em class="sig-param">conf_space</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.post_ci_analysis.generate_dets" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an ordered list of determinants.</p>
<p>This generates an ordered list of all of the determinants for the 
Fock space described by the input parameters.</p>
<p>Determinants are in the following form (indexing starts at zero):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">det</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="mi">0</span><span class="n">th</span> <span class="n">determinant</span><span class="p">,</span> <span class="n">det</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="mi">1</span><span class="n">st</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span><span class="p">)</span>
<span class="n">det</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">elim</span> <span class="p">(</span><span class="n">alpha</span><span class="p">)],</span> <span class="p">[</span><span class="n">elim</span> <span class="p">(</span><span class="n">beta</span><span class="p">)]],</span> <span class="p">[[</span><span class="n">add</span> <span class="p">(</span><span class="n">a</span><span class="p">)],</span> <span class="p">[</span><span class="n">add</span> <span class="p">(</span><span class="n">b</span><span class="p">)]]]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_SF</strong><span class="classifier">int</span></dt><dd><p>Number of spin-flips</p>
</dd>
<dt><strong>delta_ec</strong><span class="classifier">int</span></dt><dd><p>Change in electron count</p>
</dd>
<dt><strong>conf_space</strong><span class="classifier">str</span></dt><dd><p>Configuration space</p>
</dd>
<dt><strong>ras1</strong><span class="classifier">int</span></dt><dd><p>Number of RAS1 orbitals</p>
</dd>
<dt><strong>ras2</strong><span class="classifier">int</span></dt><dd><p>Number of RAS2 orbitals</p>
</dd>
<dt><strong>ras3</strong><span class="classifier">int</span></dt><dd><p>Number of RAS3 orbitals</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Ordered list of determinants</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sf_ip_ea.post_ci_analysis.print_det_list">
<code class="sig-prename descclassname">sf_ip_ea.post_ci_analysis.</code><code class="sig-name descname">print_det_list</code><span class="sig-paren">(</span><em class="sig-param">wfn</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.post_ci_analysis.print_det_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the full list of determinants to standard output.</p>
<p>This prints the full determinant list to standard output, in order. 
This does not print by default, but is useful for some post-CI analysis.
Information is printed to standard output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wfn</strong><span class="classifier">FockWfn</span></dt><dd><p>Fock CI wavefunction object with determinants to print.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sf_ip_ea.post_ci_analysis.print_dets">
<code class="sig-prename descclassname">sf_ip_ea.post_ci_analysis.</code><code class="sig-name descname">print_dets</code><span class="sig-paren">(</span><em class="sig-param">vect</em>, <em class="sig-param">wfn</em>, <em class="sig-param">dets_to_print=10</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.post_ci_analysis.print_dets" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a CI vector/state, prints information about the most important 
determinants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vect</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Eigenvector corresponding to the desired state.</p>
</dd>
<dt><strong>wfn</strong><span class="classifier">FockWfn</span></dt><dd><p>Fock CI wavefunction object for the calculation.</p>
</dd>
<dt><strong>dets_to_print</strong><span class="classifier">int</span></dt><dd><p>Number of determinants to print. Optional. Defaults to 10.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.psi4_sf">
<span id="sf-ip-ea-psi4-sf-module"></span><h2>sf_ip_ea.psi4_sf module<a class="headerlink" href="#module-sf_ip_ea.psi4_sf" title="Permalink to this headline">¶</a></h2>
<p>Fock-space CI using Psi4’s interface.</p>
<p>Runs a RAS-nSF-IP/EA calculation using Psi4 to construct the integrals.</p>
<dl class="function">
<dt id="sf_ip_ea.psi4_sf.do_sf_psi4">
<code class="sig-prename descclassname">sf_ip_ea.psi4_sf.</code><code class="sig-name descname">do_sf_psi4</code><span class="sig-paren">(</span><em class="sig-param">delta_a</em>, <em class="sig-param">delta_b</em>, <em class="sig-param">mol</em>, <em class="sig-param">conf_space=''</em>, <em class="sig-param">ref_opts={}</em>, <em class="sig-param">sf_opts={}</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.psi4_sf.do_sf_psi4" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs RAS-nSF-IP/EA using Psi4.</p>
<p>This runs a RAS-nSF-IP/EA calculation using Psi4 to solve for the 
reference state ROHF orbitals, if needed, and construct the one- and 
two-electron integral objects to pass along to the NumPy-based solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>delta_a</strong><span class="classifier">int</span></dt><dd><p>Number of alpha electrons to eliminate</p>
</dd>
<dt><strong>delta_b</strong><span class="classifier">int</span></dt><dd><p>Number of beta electrons to create</p>
</dd>
<dt><strong>mol</strong><span class="classifier">Psi4.core.Molecule</span></dt><dd><p>Psi4 Molecule object on which to run the calculation</p>
</dd>
<dt><strong>conf_space</strong><span class="classifier">str</span></dt><dd><p>Inclusion of holes/particles (Options: “”, “h”, “p”, “h,p”)</p>
</dd>
<dt><strong>ref_opts</strong><span class="classifier">dict</span></dt><dd><p>Additional options for Psi4 (see Psi4 docs)</p>
</dd>
<dt><strong>sf_opts</strong><span class="classifier">dict</span></dt><dd><p>Additional options for Fock CI</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A FockWfn object containing calculation results</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.solvers">
<span id="sf-ip-ea-solvers-module"></span><h2>sf_ip_ea.solvers module<a class="headerlink" href="#module-sf_ip_ea.solvers" title="Permalink to this headline">¶</a></h2>
<p>Davidson solver module.</p>
<p>This module holds the Davidson solver and related functions.</p>
<dl class="function">
<dt id="sf_ip_ea.solvers.davidson">
<code class="sig-prename descclassname">sf_ip_ea.solvers.</code><code class="sig-name descname">davidson</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">vInit</em>, <em class="sig-param">e_conv=1e-08</em>, <em class="sig-param">r_conv=0.0001</em>, <em class="sig-param">vect_cutoff=1e-05</em>, <em class="sig-param">maxIter=200</em>, <em class="sig-param">collapse_per_root=20</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.solvers.davidson" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the eigenvalues and eigenvectors of a Hamiltonian.</p>
<p>Uses the Davidson method to solve for the eigenvalues and eigenvectors
of a given Hermitian matrix A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">sf_ip_ea.linop.LinOpH</span></dt><dd><p>LinOp object defining our matrix-vector multiply.</p>
</dd>
<dt><strong>vInit</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Initial guess vector(s).</p>
</dd>
<dt><strong>e_conv</strong><span class="classifier">float</span></dt><dd><p>Cutoff for energy convergence. (Default: 1e-8)</p>
</dd>
<dt><strong>r_conv</strong><span class="classifier">float</span></dt><dd><p>Cutoff for residual squared convergence. (Default: 1e-4)</p>
</dd>
<dt><strong>vect_cutoff</strong><span class="classifier">float</span></dt><dd><p>Cutoff for adding vectors to Krylov space. (Default: 1e-5)</p>
</dd>
<dt><strong>maxIter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations. (Default: 200)</p>
</dd>
<dt><strong>collapse_per_root</strong><span class="classifier">int</span></dt><dd><p>Number of vectors per root to save after collapsing the Krylov space.
(Default: 20)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Eigenvalues/eigenvectors for the Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea.tei">
<span id="sf-ip-ea-tei-module"></span><h2>sf_ip_ea.tei module<a class="headerlink" href="#module-sf_ip_ea.tei" title="Permalink to this headline">¶</a></h2>
<p>Two-electron integral object handling.</p>
<p>This module handles the two-electron integrals. It generates and stores 
integrals in the form of NumPy arrays. The TEI subclasses handle 
full (TEIFullBase) and density-fitted integrals (TEIDFBase), 
and both of these have subclasses which handle the multiple ways of 
constructing the integrals (by using Psi4, by passing in pre-constructed 
NumPy arrays, and so on). When an interface to a new program is added, 
a corresponding TEI object specific to that program should be added here 
as a subclass of TEIFullBase or TEIDFBase.</p>
<p>Used Psi4NumPy Tutorials for reference for the density fitting.</p>
<dl class="class">
<dt id="sf_ip_ea.tei.TEI">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEI</code><a class="headerlink" href="#sf_ip_ea.tei.TEI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract parent class for two-electron integral object handling.</p>
<p>This class handles the two-electron integrals. It generates and stores 
integrals in the form of NumPy arrays. Relevant sub-blocks can be easily 
accessed via the <code class="docutils literal notranslate"><span class="pre">get_subblock</span></code> routine.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.tei.TEI.get_subblock" title="sf_ip_ea.tei.TEI.get_subblock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code></a>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the ERI matrix.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sf_ip_ea.tei.TEI.get_subblock">
<em class="property">abstract </em><code class="sig-name descname">get_subblock</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">c</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEI.get_subblock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a given subblock of the ERI matrix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf_ip_ea.tei.TEIDFBase">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEIDFBase</code><a class="headerlink" href="#sf_ip_ea.tei.TEIDFBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sf_ip_ea.tei.TEI" title="sf_ip_ea.tei.TEI"><code class="xref py py-class docutils literal notranslate"><span class="pre">sf_ip_ea.tei.TEI</span></code></a></p>
<p>Base class for constructing density-fitted two-electron integrals.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.tei.TEIDFBase.get_subblock" title="sf_ip_ea.tei.TEIDFBase.get_subblock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code></a>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the two-electron integrals (DF).</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sf_ip_ea.tei.TEIDFBase.get_subblock">
<code class="sig-name descname">get_subblock</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">c</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIDFBase.get_subblock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a given subblock of the two-electron integrals (DF).</p>
<p>Returns a given subblock of the DF two-electron integral object.
The RAS space to return is given by <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, 
and <code class="docutils literal notranslate"><span class="pre">d</span></code>. This function performs the contraction of the given 
bra (B_ab) and ket (B_cd) matrices using einsum. The output 
is given in physicists’ notation with the form &lt;ab|cd&gt;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 1.</p>
</dd>
<dt><strong>b</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 2.</p>
</dd>
<dt><strong>c</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 3.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 4.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>NumPy representation of the desired subblock.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf_ip_ea.tei.TEIDFNumPy">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEIDFNumPy</code><span class="sig-paren">(</span><em class="sig-param">C</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em>, <em class="sig-param">conf_space</em>, <em class="sig-param">np_tei</em>, <em class="sig-param">np_J</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIDFNumPy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sf_ip_ea.tei.TEIDFBase" title="sf_ip_ea.tei.TEIDFBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">sf_ip_ea.tei.TEIDFBase</span></code></a></p>
<p>Class for constructing TEIs using NumPy arrays.</p>
<p>This allows for construction of DF integrals using NumPy arrays as 
input. B matrices are constructed in the initialization step and 
are subsequently multiplied to form the appropriate subblocks.
B matrices are only formed for the necessary subblocks, given the 
excitation scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>B11</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS1/RAS1 B-matrix.</p>
</dd>
<dt><strong>B12</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS1/RAS2 B-matrix.</p>
</dd>
<dt><strong>B13</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS1/RAS3 B-matrix.</p>
</dd>
<dt><strong>B21</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS2/RAS1 B-matrix.</p>
</dd>
<dt><strong>B22</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS2/RAS2 B-matrix.</p>
</dd>
<dt><strong>B23</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS2/RAS3 B-matrix.</p>
</dd>
<dt><strong>B31</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS3/RAS1 B-matrix.</p>
</dd>
<dt><strong>B32</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS3/RAS2 B-matrix.</p>
</dd>
<dt><strong>B33</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>RAS3/RAS3 B-matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the two-electron integrals (DF).</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sf_ip_ea.tei.TEIDFPsi4">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEIDFPsi4</code><span class="sig-paren">(</span><em class="sig-param">C</em>, <em class="sig-param">basis</em>, <em class="sig-param">aux</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em>, <em class="sig-param">conf_space</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIDFPsi4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sf_ip_ea.tei.TEIDFBase" title="sf_ip_ea.tei.TEIDFBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">sf_ip_ea.tei.TEIDFBase</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the two-electron integrals (DF).</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sf_ip_ea.tei.TEIFullBase">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEIFullBase</code><a class="headerlink" href="#sf_ip_ea.tei.TEIFullBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sf_ip_ea.tei.TEI" title="sf_ip_ea.tei.TEI"><code class="xref py py-class docutils literal notranslate"><span class="pre">sf_ip_ea.tei.TEI</span></code></a></p>
<p>Base class for constructing full two-electron integrals.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sf_ip_ea.tei.TEIFullBase.get_full" title="sf_ip_ea.tei.TEIFullBase.get_full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_full</span></code></a>(self)</p></td>
<td><p>Returns the full set of two-electron integrals as a NumPy array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sf_ip_ea.tei.TEIFullBase.get_subblock" title="sf_ip_ea.tei.TEIFullBase.get_subblock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code></a>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the two-electron integrals.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sf_ip_ea.tei.TEIFullBase.get_full">
<code class="sig-name descname">get_full</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIFullBase.get_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full set of two-electron integrals as a NumPy array.</p>
<p>This returns the full two-electron integral (for the necessary 
RAS spaces, given the excitations) as a NumPy array. This is 
useful for storing the array for use in future calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>NumPy representation of two-electron integral object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sf_ip_ea.tei.TEIFullBase.get_subblock">
<code class="sig-name descname">get_subblock</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">c</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIFullBase.get_subblock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a given subblock of the two-electron integrals.</p>
<p>This returns a NumPy representation of a given subblock of the 
full two-electron integrals. The subblock to return is given by 
parameters <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, and <code class="docutils literal notranslate"><span class="pre">d</span></code>, where each indicates 
a RAS space (1, 2, or 3). The returned integral is in physicists’ 
notation and has the form &lt;ab|cd&gt;.</p>
<p>So to get the block with a and c in RAS1 and b and d in RAS2,
one would use get_subblock(1, 2, 1, 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 1.</p>
</dd>
<dt><strong>b</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 2.</p>
</dd>
<dt><strong>c</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 3.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int</span></dt><dd><p>RAS space of index 4.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>NumPy representation of the desired subblock.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf_ip_ea.tei.TEIFullNumPy">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEIFullNumPy</code><span class="sig-paren">(</span><em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em>, <em class="sig-param">conf_space</em>, <em class="sig-param">np_tei</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIFullNumPy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sf_ip_ea.tei.TEIFullBase" title="sf_ip_ea.tei.TEIFullBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">sf_ip_ea.tei.TEIFullBase</span></code></a></p>
<p>Class for constructing full TEI integrals from a NumPy array.</p>
<p>This class stores the integrals as a NumPy array, given a NumPy array.
Note that the relevant subset of the array should be given. So, in the 
case of a RAS(h) calculation, one would give the TEI constructed in the 
basis of RAS1 and RAS2 orbitals only (not RAS3).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>eri</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Numpy representation of the relevant two-electron integrals.</p>
</dd>
<dt><strong>ind</strong><span class="classifier">list</span></dt><dd><p>A list of index ranges for the subblocks (RAS1, RAS2, RAS3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_full</span></code>(self)</p></td>
<td><p>Returns the full set of two-electron integrals as a NumPy array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the two-electron integrals.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sf_ip_ea.tei.TEIFullPsi4">
<em class="property">class </em><code class="sig-prename descclassname">sf_ip_ea.tei.</code><code class="sig-name descname">TEIFullPsi4</code><span class="sig-paren">(</span><em class="sig-param">C</em>, <em class="sig-param">basis</em>, <em class="sig-param">ras1</em>, <em class="sig-param">ras2</em>, <em class="sig-param">ras3</em>, <em class="sig-param">conf_space</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.tei.TEIFullPsi4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sf_ip_ea.tei.TEIFullBase" title="sf_ip_ea.tei.TEIFullBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">sf_ip_ea.tei.TEIFullBase</span></code></a></p>
<p>Class for constructing full TEI integrals using Psi4.</p>
<p>This class constructs the full two-electron integrals using Psi4. 
It then stores the integrals as NumPy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>eri</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Numpy representation of the relevant two-electron integrals.</p>
</dd>
<dt><strong>ind</strong><span class="classifier">list</span></dt><dd><p>A list of index ranges for the subblocks (RAS1, RAS2, RAS3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_full</span></code>(self)</p></td>
<td><p>Returns the full set of two-electron integrals as a NumPy array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subblock</span></code>(self, a, b, c, d)</p></td>
<td><p>Returns a given subblock of the two-electron integrals.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-sf_ip_ea">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-sf_ip_ea" title="Permalink to this headline">¶</a></h2>
<p>A program for running RAS-SF-IP/EA calculations.</p>
<p>This program runs RAS-SF-IP/EA calculations using an efficient 
tensor-contraction-based scheme. The contractions have been hand-derived and 
use NumPy’s einsum for efficiency. The program is run primarily through 
the main <code class="docutils literal notranslate"><span class="pre">fock_ci</span></code> function.</p>
<dl class="function">
<dt id="sf_ip_ea.fock_ci">
<code class="sig-prename descclassname">sf_ip_ea.</code><code class="sig-name descname">fock_ci</code><span class="sig-paren">(</span><em class="sig-param">delta_a</em>, <em class="sig-param">delta_b</em>, <em class="sig-param">mol</em>, <em class="sig-param">conf_space=''</em>, <em class="sig-param">ref_opts={}</em>, <em class="sig-param">sf_opts={}</em>, <em class="sig-param">program='PSI4'</em><span class="sig-paren">)</span><a class="headerlink" href="#sf_ip_ea.fock_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Fock-space CI (SF-IP/EA).</p>
<p>This is the main function call for the program. Given the changes in 
alpha and beta electron counts, it performs the correct number of 
spin-flips and IP/EAs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>delta_a</strong><span class="classifier">int</span></dt><dd><p>Desired number of alpha electrons to remove.</p>
</dd>
<dt><strong>delta_b</strong><span class="classifier">int</span></dt><dd><p>Desired number of beta electrons to add.</p>
</dd>
<dt><strong>mol</strong><span class="classifier">Molecule</span></dt><dd><p>The molecule object to run the calculation on. 
This should be built in whichever program you’ll use 
to run the reference, and should be handled properly by the 
reference program.</p>
</dd>
<dt><strong>conf_space</strong><span class="classifier">string</span></dt><dd><dl class="simple">
<dt>Desired configuration space/additional excitations.</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> CAS</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;h&quot;</span></code> 1 hole excitation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;p&quot;</span></code> 1 particle excitation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;h,p&quot;</span></code> 1 hole + 1 particle excitation</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>ref_opts</strong><span class="classifier">dict</span></dt><dd><p>Options for the reference program.
See relevant reference program docs (ex. Psi4 docs) for details.</p>
</dd>
<dt><strong>sf_opts</strong><span class="classifier">dict</span></dt><dd><dl class="simple">
<dt>Additional options for stand-alone SF code. </dt><dd><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sf_diag_method</span></code>: Diagonalization method to use.</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RSP</span></code> Direct (deprecated)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LANCZOS</span></code> Use NumPy’s Lanczos</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DAVIDSON</span></code> Use our Davidson</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_roots</span></code>: Number of roots to solve for.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">guess_type</span></code>: Type of guess vector to use</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">CAS</span></code> Do CAS first and use that as an initial guess.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RANDOM</span></code> Random orthonormal basis</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">READ</span></code> Read guess from a NumPy file (TODO)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">integral_type</span></code>: Which integrals to use (DF or FULL)</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">FULL</span></code> Use full integrals (no density fitting)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DF</span></code> Use density fit integrals</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sf_wfn</dt><dd><p>Wavefunction object (sf_wfn) containing calculation data and results</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">sf_ip_ea package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.bloch">sf_ip_ea.bloch module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.f">sf_ip_ea.f module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.linop">sf_ip_ea.linop module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.np_sf">sf_ip_ea.np_sf module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.post_ci_analysis">sf_ip_ea.post_ci_analysis module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.psi4_sf">sf_ip_ea.psi4_sf module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.solvers">sf_ip_ea.solvers module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea.tei">sf_ip_ea.tei module</a></li>
<li><a class="reference internal" href="#module-sf_ip_ea">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/sf_ip_ea.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CAS-nSF-IP/EA  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Shannon E. Houck.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>